<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="description" content="Linux bash. Примеры. Переменные окружения. Работа со строками. Условные переходы">
<meta name="keywords" content="linux, bash, shell, переменные, строки, примеры, скрипты, basename, dirname"> 
<meta name="title" content="Bash в примерах. Часть 1."> 
<meta http-equiv="сontent-language" content="ru">
<link rel="stylesheet" type="text/css" media="screen" href="Bash%20%D0%B2%20%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D0%B0%D1%85.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%201._files/default.css">
<link rel="icon" href="http://linuxgeeks.ru/favicon.ico" type="image/x-icon">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Bash в примерах. Часть 1.</title>
<link rel="preload" href="Bash%20%D0%B2%20%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D0%B0%D1%85.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%201._files/integrator.js" as="script"><script src="Bash%20%D0%B2%20%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D0%B0%D1%85.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%201._files/ca-pub-8433592019700240.js"></script><script type="text/javascript" src="Bash%20%D0%B2%20%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D0%B0%D1%85.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%201._files/integrator.js"></script><link rel="preload" href="Bash%20%D0%B2%20%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D0%B0%D1%85.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%201._files/integrator_002.js" as="script"><script type="text/javascript" src="Bash%20%D0%B2%20%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D0%B0%D1%85.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%201._files/integrator_002.js"></script><link rel="prefetch" href="https://securepubads.g.doubleclick.net/static/3p_cookie.html"></head>

<body>
<div class="container">
	<div class="header">
		<div class="title"><a href="http://linuxgeeks.ru/" title="Перейти на главную страницу">LinuxGeeks.ru</a></div>

<ul class="topmenu"><li><a href="http://linuxgeeks.ru/" title="О линуксе для новичков">Главная страница</a></li>
<li><a href="http://linuxgeeks.ru/about.htm" title="О сайте">О сайте</a></li>
<li class="last"><a href="http://linuxgeeks.ru/test.htm" title="Проверь себя">Проверь себя</a></li>
</ul>

<div class="clearer"></div>
	</div>
	<div class="main">
<div class="content">
<h1>Bash в примерах. Часть первая.</h1>
<h2>Основы программирования в bash</h2>
<h3>Введение</h3>
<p>Вы, должно быть, пока не представляете зачем нужно учиться программированию в bash. Вот несколько  причин:</p>

<h3>Bash уже есть у вас в системе</h3>
<p><a href="http://linuxgeeks.ru/bash-intro.htm" title="Основы Linux: введение в bash.">Если вы проверите</a>,
 то скорее всего обнаружите, что bash уже запущен у вас в системе. Даже 
если вы используете другой shell в качестве командного интерпретатора, 
bash наверняка установлен, потому что он является стандартной командной 
оболочкой в линуксе. Так как bash уже запущен, выполнение скриптов 
написанных на bash-е является эффективным, потому что они разделяют 
часть оперативной памяти с уже запущенным процессом bash. Да и зачем 
загружать еще один интерпретатор, если у вас уже есть bash, который 
справляется со своей работой и делает это хорошо?</p>

<h3>Вы уже используете его</h3>
<p>Но bash не просто запущен в вашей системе, вы еще ежедневно 
взаимодействуете с ним. Он всегда рядом, так что есть смысл научиться 
управляться с ним чтобы полноценно использовать все его возможности. 
После этого ваше общение с линуксом станет намного веселее и 
продуктивнее. Но почему вы должны учиться программировать? Все просто: 
вы уже мыслите в терминах исполнения программ, копирования файлов и 
перенаправления вывода программ. Не должны ли вы теперь изучить язык, 
который позволит вам строить из этих простых элементов мощные и 
экономящие ваше время конструкции с использованием которых вы уже 
знакомы? Командная оболочка открывает перед вами весь потенциал UNIX. А 
bash это командная оболочка линукс. Он связывает вас с компьютером. 
Изучив bash, вы автоматически увеличите свою производительность 
использования UNIX или Linux — все настолько просто.</p>

<h3>Перед началом</h3>
<p>Неправильный подход к изучению языка bash может сбить вас с толку. Многие новички вводят команду <b>man bash</b>
 чтобы прочитать страницу со справкой, которая содержит только краткое 
техническое описание функционала командной оболочки. Другие вызывают <b>info bash</b>
 (чтобы посмотреть документацию в формате info), но получают или ту же 
страницу мануала или немногим более удобный для пользователя материал.</p>
<p>Новички могут быть немного разочарованы, узнав что стандартная 
справка не может предоставить всей информации и предназначена для 
пользователей уже знакомых с основами программирования на языке shell. В
 мануале много замечательно организованной технической информации, но 
для новичков ее польза невелика.</p>
<p>Эта серия статей поможет вам освоиться в командной строке. В этом 
пособии описано как использовать основные синтаксические конструкции 
языка shell для написания своих скриптов. Я постараюсь объяснить все 
простым языком, чтобы вы не только поняли как это все работает, но и 
разобрались как это использовать. Прочитав эту серию статей, вы 
научитесь писать свои собственные скрипты и будете комфортно себя 
чувствовать в командной строке. После этого вы сможете пополнять свои 
знания читая (и понимая!) стандартную документацию по bash. Давайте 
начнем.</p>

<h3>Переменные окружения</h3>
<p>В bash как и практически во всех остальных командных оболочках 
пользователь может создавать и определять свои переменные окружения, 
которые хранятся как текстовые (ASCII) строки. Одно из самых полезных 
свойств переменных окружения заключается в том, что они являются 
стандартной частью модели процессов в UNIX. Это значит, что переменные 
окружения могут использовать не только скрипты командной оболочки, но и 
компилированные программы. Когда мы экспортируем переменную окружения в 
bash, любая программа запущенная нами получает к ней доступ. Хорошим 
примером служит команда <b>vipw</b>, которая позволяет руту редактировать файл с паролями пользователей (<i>/etc/passwd</i>). Установив переменную окружения <b>EDITOR</b> в значение своего любимого <a href="http://linuxgeeks.ru/vi.htm">текстового редактора</a>, вы можете указать vipw использовать его, а не редактор по умолчанию.</p>
<p>Переменную в bash-е можно определить следующим способом:</p>
<code>$ <b>myvar='Это моя переменная окружения!'</b></code>
<p>Эта команда создает переменную с именем "myvar" которая содержит 
строку "Это моя переменная окружения!". Следует заметить что: Во-первых,
 рядом со знаком "<b>=</b>" не должно быть пробелов; (попробуйте и вы 
увидите, что на команду с пробелами интерпретатор выдает ошибку). 
Во-вторых, если значение нашей переменной содержит пробелы или знаки 
табуляции, нужно заключить его в кавычки.</p>
<div class="note"><strong>Замечание:</strong> За подробной информацией об использовании кавычек в bash обратитесь к разделу "QUOTING" на странице <b>man bash</b>.
 Существование специальных последовательностей символов, которые 
интерпретатор заменяет другими значениями, делает объяснение работы со 
строками в bash слишком сложным. Поэтому мы расскажем только о наиболее 
часто используемых способах применения кавычек.</div>
<p>В-третьих, обычно можно использовать двойные кавычки вместо 
одинарных, но именно в этом примере использование двойных кавычек 
вызовет ошибку интерпретатора, так как значение нашей переменной 
содержит один из тех специальных символов (о которых сказано в замечании
 выше) — "<b>!</b>", но внутри одинарных кавычек никакие специальные символы не работают. Символ "<b>!</b>" в bash отвечает за так называемую "<i>HISTORY EXPANSION</i>"
 — работу с файлом истории командной строки (подробности см. в мануале).
 На смотря на то, что функция работы с историей команд при помощи "<b>!</b>" бывает очень полезной, именно сейчас мы хотим видеть его просто как восклицательный знак.</p>
<p>Давайте посмотрим как можно прочитать значение нашей переменной:</p>
<code>$ <b>echo $myvar</b>
Это моя переменная окружения!</code>

<p>Ставя перед именем переменной знак <b>$</b>, мы сообщаем 
интерпретатору, что нужно заменить ее значением. Это называется 
подстановкой переменной (variable substitution/expansion).</p>
<div class="note">Нужно заметить, что имена переменных в bash чувствительны к регистру. Например, <b>myvar</b> и <b>Myvar</b> — это имена разных переменных.</div>

<p>Но что будет, если мы попробуем сделать так:</p>
<code>$ <b>echo foo$myvarbar</b>
foo</code>
<p>Мы хотели вывести на экран надпись '<i>fooЭто моя переменная окружения!bar</i>',
 но ничего не получилось. Что же произошло? Интерпретатор не смог 
определить значение какой именно переменной нужно подставить ($m, $my, 
$myvar, $myvarbar и т.д.) В таких неоднозначных случаях можно явно 
указать bash на имя переменной:</p>
<code>$ <b>echo foo${myvar}bar</b>
fooЭто моя переменная окружения!bar</code>
<p>Как вы видите, заключив имя нужной переменной в фигурные скобки, мы 
явно указали интерпретатору где находится переменная, а где простой 
текст. Выражение $myvar быстрее напечатать и оно работает в большинстве 
случаев, но ${myvar} будет работать всегда корректно. Оба этих выражения
 указывают на одну переменную, но вы должны использовать второе (с 
фигурными скобками), если имя переменной не отделено от окружающего 
текста пробелами или знаками табуляции.</p>
<p>Вернемся к упомянутой нами возможности экспортировать переменные. 
Экспортированная переменная автоматически становится доступна для любого
 скрипта или программы, запущенной после экспортирования. Shell-скрипт 
может прочитать значение переменной при помощи встроенных в shell 
средств работы с переменными окружения, а программы на C — используя 
функцию getenv(). Вот небольшой пример кода на языке C, который вы 
можете напечатать и скомпилировать. Он поможет взглянуть на переменные 
окружения со стороны языка C:</p>
<code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void) {
  char *myenvvar=getenv("EDITOR");
  printf("The editor environment variable is set to %s\\n",myenvvar);
}</code>
<p>Сохраните этот код в файл <b>myenv.c</b>, а затем скомпилируйте:</p>
<code>$ <b>gcc myenv.c -o myenv</b></code>
<p>После этого в ващей рабочей директории появится исполняемый файл '<b>myenv</b>'. Запустите его, и он выведет вам значение переменной '<b>EDITOR</b>' (если оно присвоено). Вот что получилось у меня:</p>
<code>$ <b>./myenv</b>
The editor environment variable is set to (null)</code>
<p>Так как переменная не определена, наша программа не может получить к 
ней доступ. Давайте создадим эту переменную и  присвоим ей какое-нибудь 
значение:</p>
<code>$ <b>EDITOR=mousepad</b>
$ <b>./myenv</b>
The editor environment variable is set to (null)</code>
<p>Так тоже не работает. Мы ожидали что программа напечатает "mousepad",
 но результат не изменился. Это произошло потому что мы забыли 
экспортировать переменную '<b>EDITOR</b>'. В этот раз должно сработать:</p>
<code>$ <b>export EDITOR</b>
$ <b>./myenv</b>
The editor environment variable is set to mousepad</code>
<p>Итак, мы на примере убедились, что сторонний процесс (в нашем случае 
программа на C) не может получить доступ к переменной окружения до тех 
пор пока она не экспортирована. Кроме того, вы можете определить 
переменную и экспортировать ее одной командой:</p>
<code>$ <b>export EDITOR=mousepad</b></code>
<p>Эта команда выполняет то же действие, что и двухшаговая версия 
(присвоение значения и экспорт). Наступило подходящее время показать как
 сбросить значение переменной окружения (другими словами — удалить 
переменную) при помощи '<b>unset</b>':</p>
<code>$ <b>unset EDITOR</b>
$ <b>./myenv</b>
The editor environment variable is set to (null)</code>


<h3>Как распарсить строку?</h3>
<p>Распарсить строку — значит разделить ее на более короткие 
составляющие. Это одна из частых операций, встречающихся при написании 
shell-скриптов. Иногда скрипту нужно определить имя конкретного файла 
или директории, зная полный (абсолютный) путь к нему. На bash это можно 
сделать всего одной командой:</p>
<code>$ <b>basename /usr/local/share/doc/foo/foo.txt</b>
foo.txt
$ <b>basename /usr/home/drobbins</b>
drobbins</code>
<p>'<b>basename</b>' — очень удобная утилита для расщепления строк на составляющие. Вторая команда — '<b>dirname</b>' — возвращает другую часть строки (путь к директории где находится файл):</p>
<code>$ <b>dirname /usr/local/share/doc/foo/foo.txt</b>
/usr/local/share/doc/foo
$ <b>dirname /usr/home/drobbins/</b>
/usr/home</code>
<div class="note"><strong>Замечание</strong>: команды '<b>basename</b>' и '<b>dirname</b>' не определяют наличие файла или директории в файловой системе, а работают только со строками.</div>

<h3>Подстановка команд</h3>
<p>Очень полезно знать как присвоить переменной результат выполнения какой-либо команды. Сделать это довольно просто:</p>
<code>$ <b>MYDIR=$(dirname /usr/local/share/doc/foo/foo.txt)</b>
$ <b>echo $MYDIR</b>
/usr/local/share/doc/foo</code>
<p>То что мы сделали называется <i>подстановка команд</i>. В первой строке примера мы просто заключили команду в конструкцию <b>$(&nbsp;)</b>.</p>
<p>Заметим, что тоже самое можно сделать применив вместо конструкции <b>$(&nbsp;)</b> обратные кавычки <b>``</b> (клавиша клавиатуры сразу над клавишей Tab):</p>
<code>$ <b>MYDIR=`dirname /usr/local/share/doc/foo/foo.txt`</b>
$ <b>echo $MYDIR</b>
/usr/local/share/doc/foo</code>
<p>В баше, как мы видим, можно сделать одно действие несколькими разными
 способами. Используя подстановку команд, мы можем поместить любую 
команду в обратные кавычки или в конструкцию <b>$(&nbsp;)</b> и 
присвоить ее вывод переменной. Очень полезная вещь! Вот пример как 
использовать подстановку серии команд соединенных через пайп:</p>
<code>$ <b>MYFILES=$(ls -1 /etc | grep ^pa)</b>
$ <b>echo $MYFILES</b>
pam.conf
pam.d
pango
papersize
passwd
passwd-</code>
<p>Стоит заметить, что использование конструкции <b>$(&nbsp;)</b> 
предпочтительней чем обратных кавычек в shell-скриптах, т.к. она более 
универсальна по отношению к разным командным интерпретаторам, ее легче 
набирать и читать и ее можно использовать во вложенных конструкциях:</p>
<code>$ <b>MYFILES=$(ls $(dirname foo/bar/oni))</b></code>

<h3>Расщепление строк для профессионалов</h3>
<p>'<b>basename</b>' и '<b>dirname</b>' замечательные утилиты, но бывают
 случаи, когда нужно произвести более сложные операции над строками чем 
манипуляции с путями. Для более эффективной работы со строками можно 
использовать встроенные средства подстановки значений переменных bash. 
Ранее мы уже использовали подстановку переменных, которая выглядела так:
 ${myvar}. Но в bash есть и встроенные средства манипуляции со строками.
 Посмотрим на следующий пример:</p>
<code>$ <b>MYVAR=foodforthought.jpg</b>
$ <b>echo ${MYVAR##*fo}</b>
rthought.jpg
$ <b>echo ${MYVAR#*fo}</b>
odforthought.jpg</code>
<p>Что же означает конструкция <b>${MYVAR##*fo}</b> из предыдущего 
примера? Мы написали внутри ${&nbsp;} имя переменной, затем два знака 
хэша (или диеза, кому как привычней) и шаблон ("*fo"). Bash взял нашу 
переменную 'MYVAR', нашел наибольшую по длине подстроку строки 
'foodforthought.jpg' (начиная от начала строки) которая совпала с 
шаблоном "*fo" и удалил ее. С первого раза в этих тонкостях сложно 
разобраться. Для того чтобы понять как работает конструкция <b>##</b>, 
давайте рассмотрим пошагово как bash ищет совпадение подстроки с 
шаблоном. Начинаем поиск подстроки совпадающей с шаблоном "*fo" с начала
 строки "foodforthought.jpg". Вот список всех таких подстрок:</p>
<code>f
fo              совпадает с шаблоном "*fo"
foo
food
foodf
foodfo          совпадает с шаблоном "*fo"
foodfor
foodfort
foodforth
foodfortho
foodforthou
foodforthoug
foodforthought
foodforthought.j
foodforthought.jp
foodforthought.jpg</code>
<p>После проверки всех этих вариантов, найдено две строки попадающие под
 шаблон. Bash выбирает самую длинную из них, а затем удаляет эту 
подстроку и возвращает результат.</p>
<p>Вторая форма подстановки переменной показанная в примере отличается от первой только наличием одного знака хэша (<b>#</b>),
 а не двух. И bash выполняет те же действия, за исключением того, что 
удаляет не самую длинную а самую короткую из совпавших с шаблоном 
подстрок. Как видно, после удаления самой короткой подстроки совпавшей с
 шаблоном (fo) у нас остается строка "odforthought.jpg". </p>
<p>Это может показаться очень запутанным, поэтому я покажу как можно 
быстро запомнить эту фичу bash. Когда мы ищем самое длинное совпадение, 
то используем два хэша (##), т.к. "##" длиннее чем "#". А когда ищем 
самое короткое совпадение, используем #. Видите, не так уж и сложно! 
Постойте, а как же запомнить, что поиск начинается от начала строки? 
Очень просто! Заметим, что в английской раскладке клавиатуры сочетание 
Shift–4 дает нам знак $ используемый в bash для подстановки значения 
переменной. Сразу перед знаком $ на клавиатуре находится # (как бы 
вначале) и таким образом "#" удаляет символы от начала строки. Вы 
захотите узнать, как удалить последовательность символов от конца 
строки. Как можно догадаться, это делается при помощи знака (%), 
находящегося на клавиатуре сразу после "$". Вот небольшой пример 
удаления окончания строки:</p>
<code>$ <b>MYFOO="chickensoup.tar.gz"</b>
$ <b>echo ${MYFOO%%.*}</b>
chickensoup
$ <b>echo ${MYFOO%.*}</b>
chickensoup.tar</code>
<p>Как вы видите, одинарный и двойной знаки процента (% и %%) работают 
также как "#" и "##", но удаляют подстроку совпавшую с шаблоном от конца
 строки. Запомните, что можно не использовать знак "*", если вы хотите 
удалить какое-то конкретное окончание строки.</p>
<code>$ <b>MYFOOD="chickensoup"</b>
$ <b>echo ${MYFOOD%%soup}</b>
chicken</code>
<p>В этом примере нет разницы использовать % или %%, т.к. есть только 
одно совпадение. И не забывайте при выборе "#" или "%" смотреть на 3,4 и
 5 клавиши клавиатуры.</p>
<p>Мы можем использовать еще одну форму подстановки значения переменной для выделения подстроки по заданной длине и позиции начала:</p>
<code>$ <b>EXCLAIM=cowabunga</b>
$ <b>echo ${EXCLAIM:0:3}</b>
cow
$ <b>echo ${EXCLAIM:3:7}</b>
abunga</code>
<p>Эта форма очень удобна. Просто укажите разделяя двоеточиями позицию 
начала подстроки — первое число и длину подстроки — второе число.</p>

<h3>Применение расщепления строк</h3>
<p>Разделению строк научились, давайте теперь напишем небольшой 
shell-скрипт. Наш скрипт будет принимать один аргумент — имя файла и 
если этот файл имеет расширение .tar, скрипт будет сообщать что это 
тарбол. (На самом деле определять тип файла по расширению не совсем 
корректно. Для этих целей существует команда <b>file</b>. Пример только для демонстрации.) Вот этот скрипт:</p>
<code>#!/bin/bash

if [ "${1##*.}" = "tar" ]
then
       echo "Кажется это тарбол."
else
       echo "На первый взгляд, это не похоже на тарбол."
fi</code>
<p>Первая строка обязательно должна присутствовать в каждом скрипте. Она
 показывает путь к интерпретатору, который будет выполнять скрипт. Ее 
синтаксис, как видно из примера — "#!&lt;путь к интерпретатору&gt;".</p>
<p>Сохраните текст скрипта из примера в файл <b>mytar.sh</b>, затем измените права доступа к нему '<b>chmod 755 mytar.sh</b>'
 (это сделает файл исполняемым). И, наконец, запустите скрипт с 
аргументом в виде имени файла, как показано в следующем примере:</p>
<code>$ <b>./mytar.sh thisfile.tar</b>
Кажется это тарбол.
$ <b>./mytar.sh thatfile.gz</b>
На первый взгляд, это не похоже на тарбол.</code>
<p>Хорошо, вроде работает, но не очень функционален. Перед тем как усовершенствовать наш скрипт, рассмотрим конструкцию <b>if</b>, использованную в нем. В квадратных скобках сравниваются две строки ("<b>=</b>"
 — это оператор сравнения в bash). Результат сравнения — булевое 
выражение 'false' или 'true' (правда или ложь). Но давайте посмотрим 
какие именно строки сравниваются. Справа все понятно — строка "tar". 
Слева стоит разобранное нами выше выражение, удаляющее начало строки в 
переменной $1 по шаблону "<b>*.</b>" (вся строка до последней точки, 
т.к. используются два хэша ##). После этой операции подстановки остается
 только часть строки после последней точки — расширение другими словами.
 Если в переменной $1 содержится имя файла с расширением "tar", то 
результатом сравнения строк будет булевое true.</p>

<p>Вам наверное интересно, почему при проверке условия мы использовали 
переменную "$1". Все очень просто: переменная $1 содержит в себе первый 
аргумент переданный скрипту ($2 — второй аргумент и так далее). С этой 
функцией разобрались, рассмотрим теперь подробнее конструкцию условного 
выбора "<b>if</b>".</p>

<h3>Конструкция if</h3>
<p>Как и во многих языках программирования, в bash есть условные 
конструкции. Они имеют формат, описанный ниже. Будьте внимательны: слова
 "if" и "then" должны находится на разных строках. Старайтесь 
выравнивать горизонтально всю конструкцию, включая заключительный "fi" и
 все "else". Это делает код намного удобнее для чтения и отладки. В 
дополнении к простой форме "if,else" есть еще несколько других форм 
условных конструкций:</p>
<code>if      [ условие ]
then
        действие
fi</code>
<p>В приведенном выше примере 'действие' выполняется только если 
'условие' верно, в противном случае скрипт продолжает выполнение 
инструкций со строки идущей за "fi".</p>
<code>if [ условие ]
then 
        действие
elif [ условие_2 ]
then
        действие_2
elif [ условие_3 ]
then
.
.
.
else
        действие_x
fi</code>
<p>А эта конструкция последовательно проверяет условия и если они верны,
 то исполняет соответствующее действие. Если ни одно из условий не 
верно, то выполняется 'действие_x' стоящее после 'else' (если оно есть).
 Потом продолжается исполнение команд идущих за этой конструкцией 
"if,then,else", если таковые есть.</p>

<h3>В следующей части</h3>
<p>В этой статье мы рассмотрели базовую функциональность bash. Пришло 
время немного ускориться и начать писать свои собственные shell-скрипты.
 В следующей части пособия я расскажу о функциях, циклах, пространстве 
имен и о других важных вещах. После этого мы будем готовы писать 
относительно сложные скрипты. До встречи!</p>

<h4>Смотри также</h4>
<ul>
<li><a href="http://linuxgeeks.ru/bash-intro.htm" title="Основы Linux: введение в bash.">Основы Linux: введение в bash</a></li>
<li><a href="http://linuxgeeks.ru/bash-2.htm" title="Bash в примерах. Часть 2.">Bash в примерах. Часть 2.</a></li>
</ul>
<hr>
<p>Оригинал статьи— <a href="http://www.funtoo.org/wiki/Bash_by_Example,_Part_1" title="Bash by example, Part 1" target="_blank">Bash by example, Part 1</a> (eng)</p>
</div>

<div class="sidenav">
<h2>Популярные статьи</h2>

<ul><li><a href="http://linuxgeeks.ru/debian-archiv.htm" title="Локальный репозитарий Debian linux">Локальный репозитарий Debian linux</a></li>
<li><a href="http://linuxgeeks.ru/firstime.htm" title="Какой linux выбрать?">Какой linux выбрать?</a></li>
<li><a href="http://linuxgeeks.ru/disk.htm" title="Разметка жёсткого диска при установке linux">Разметка жёсткого диска при установке linux</a></li>
<li><a href="http://linuxgeeks.ru/shell.htm" title="Основные команды администрирования linux">Основные команды администрирования linux</a></li>
<li><a href="http://linuxgeeks.ru/kernel.htm" title="Ручная сборка ядра linux">Ручная сборка ядра linux</a></li>
<li><a href="http://linuxgeeks.ru/vi.htm" title="Использование редактора Vim">Использование редактора Vim</a></li>
<li><a href="http://linuxgeeks.ru/sed.htm" title="Потоковый редактор SED">Потоковый редактор SED</a></li>
<li><a href="http://linuxgeeks.ru/awk.htm" title="Язык обработки шаблонов AWK">Язык обработки шаблонов AWK</a></li>
<li><a href="http://linuxgeeks.ru/smb.htm" title="Firefox + samba">Firefox + samba</a></li>
<li><a href="http://linuxgeeks.ru/live-usb.htm" title="Создание Live-usb">Создание Live-usb</a></li>
<li><a href="http://linuxgeeks.ru/web-browser.htm" title="Сравнение бесплатных веб-браузеров">Сравнение бесплатных веб-браузеров</a></li>
<li><a href="http://linuxgeeks.ru/ext3grep.htm" title="Восстановление файлов на ext3">Восстановление файлов на ext3</a></li>
<li><a href="http://linuxgeeks.ru/bash-intro.htm" title="Введение в bash">Введение в bash</a></li>
<li class="active"><a href="http://linuxgeeks.ru/bash-1.htm" title="Bash в примерах. Часть I.">Bash в примерах. Часть I.</a></li>
<li><a href="http://linuxgeeks.ru/bash-2.htm" title="Bash в примерах. Часть II.">Bash в примерах. Часть II.</a></li>
<li><a href="http://linuxgeeks.ru/djvu.htm" title="Создание документов DJVU">Создание документов DJVU</a></li>
<li><a href="http://linuxgeeks.ru/try-linux.htm" title="Как попробовать линукс">Как попробовать линукс</a></li>
<li class="last"><a href="http://linuxgeeks.ru/my-software-choice.htm" title="Вариант набора ПО для GNU/Linux">Вариант набора ПО для GNU/Linux</a></li>
</ul>


<div class="lg-sq">
<script async="" src="Bash%20%D0%B2%20%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D0%B0%D1%85.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%201._files/adsbygoogle.js"></script>
<!-- lg-sq -->
<ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-8433592019700240" data-ad-slot="4866229215" data-adsbygoogle-status="done"><ins id="aswift_0_expand" style="display:inline-table;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><ins id="aswift_0_anchor" style="display:block;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><iframe marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_0" name="aswift_0" style="left:0;position:absolute;top:0;width:336px;height:280px;" width="336" height="280" frameborder="0"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>

	</div>

<div class="clearer"></div>

</div>
<div class="pad"></div>
</div>

<!-- Copyrites -->
<div class="footer">
<div>
<!--noindex-->
<!--LiveInternet counter--><script type="text/javascript"><!--
document.write("<a href='//www.liveinternet.ru/click' "+
"target=_blank><img src='//counter.yadro.ru/hit?t45.11;r"+
escape(document.referrer)+((typeof(screen)=="undefined")?"":
";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
";h"+escape(document.title.substring(0,80))+";"+Math.random()+
"' alt='' title='LiveInternet' "+
"border='0' width='31' height='31'><\/a>")
//--></script><a href="http://www.liveinternet.ru/click" target="_blank"><img src="Bash%20%D0%B2%20%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D0%B0%D1%85.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%201._files/hit.gif" alt="" title="LiveInternet" border="0" width="31" height="31"></a><!--/LiveInternet-->
<!--/noindex-->
</div>
<p>© 2009-2014 <a href="http://linuxgeeks.ru/">LinuxGeeks.ru</a> -- <a href="http://linuxgeeks.ru/sitemap.htm">Карта сайта</a></p>
</div>
<!-- Copyrites -->

</body></html>