<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="description" content="Linux bash. Примеры. Скрипты. Циклы. Функции. Переменные.">
<meta name="keywords" content="linux, bash, shell, case, while, until, loop, примеры, строки, сравнение, файлы, скрипты"> 
<meta name="title" content="Bash в примерах. Часть 2."> 
<meta http-equiv="сontent-language" content="ru">
<link rel="stylesheet" type="text/css" media="screen" href="Bash%20%D0%B2%20%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D0%B0%D1%85.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%202._files/default.css">
<link rel="icon" href="http://linuxgeeks.ru/favicon.ico" type="image/x-icon">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Bash в примерах. Часть 2.</title>
<link rel="preload" href="Bash%20%D0%B2%20%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D0%B0%D1%85.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%202._files/integrator_002.js" as="script"><script src="Bash%20%D0%B2%20%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D0%B0%D1%85.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%202._files/ca-pub-8433592019700240.js"></script><script type="text/javascript" src="Bash%20%D0%B2%20%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D0%B0%D1%85.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%202._files/integrator_002.js"></script><link rel="preload" href="Bash%20%D0%B2%20%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D0%B0%D1%85.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%202._files/integrator.js" as="script"><script type="text/javascript" src="Bash%20%D0%B2%20%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D0%B0%D1%85.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%202._files/integrator.js"></script><link rel="prefetch" href="https://securepubads.g.doubleclick.net/static/3p_cookie.html"></head>

<body>
<div class="container">
	<div class="header">
		<div class="title"><a href="http://linuxgeeks.ru/" title="Перейти на главную страницу">LinuxGeeks.ru</a></div>

<ul class="topmenu"><li><a href="http://linuxgeeks.ru/" title="О линуксе для новичков">Главная страница</a></li>
<li><a href="http://linuxgeeks.ru/about.htm" title="О сайте">О сайте</a></li>
<li class="last"><a href="http://linuxgeeks.ru/test.htm" title="Проверь себя">Проверь себя</a></li>
</ul>

<div class="clearer"></div>
	</div>
	<div class="main">
<div class="content">
<h1>Bash в примерах. Часть вторая.</h1>
<h2>Еще больше основ программирования в bash</h2>
<h3>Обработка аргументов</h3>
<p> Давайте разберемся как передавать и обрабатывать аргументы скрипта и ознакомимся с основными управляющими конструкциями bash.</p>
<p>В простом скрипте из <a href="http://linuxgeeks.ru/bash-1.htm" title="Bash в примерах. Часть 1.">предыдущей статьи</a> мы использовали переменную "<b>$1</b>",
 которая содержит первый аргумент командной строки при вызове скрипта. 
Аналогично можно использовать "$2", "$3" и так далее для доступа ко 
второму, третьему... аргументам командной строки. Вот пример:</p>
<code>#!/bin/bash

echo "Имя скрипта — $0"
echo "Первый аргумент: $1"
echo "Второй аргумент: ${2}"
echo "Семнадцатый аргумент: ${17}"
echo "Количество аргументов: $#"</code>
<p>Обратите внимание, что в переменной "<b>$0</b>" содержится имя самого скрипта, который запущен из командной строки. А переменная "<b>$#</b>"
 содержит количество переданных скрипту аргументов. Использование 
фигурных скобок необязательно только для переменных состоящих из одной 
цифры (с $0 по $9). Попробуйте позапускать этот скрипт с разным числом 
аргументов и посмотрите как он работает.</p>
<p>Иногда необходимо сослаться сразу на все аргументы командной строки. Для этого в bash есть специальная переменная "<b>$@</b>",
 которая содержит все аргументы переданные скрипту разделенные 
пробелами. Мы будем использовать эту переменную чуть позже при рассказе о
 циклах со счетчиком (конструкция "for").</p>

<h3>Управляющие конструкции bash</h3>
<p>Если вы раньше программировали на процедурных языках, таких как Си, 
Паскаль, Перл и тому подобных, вам должны быть знакомы управляющие 
конструкции вроде "if", "for" и другие. В bash тоже есть все эти 
конструкции. В следующих разделах пособия я познакомлю вас с ними и 
покажу чем они отличаются от подобных конструкций из других языков 
программирования. Если вы раньше не программировали — не волнуйтесь. 
Материал будет изложен подробно и дополнен примерами, так что даже 
новичок в программировании сможет разобраться.</p>

<h3>Оператор условного выбора "if"</h3>
<p>Если вы раньше программировали на языке Си, то должны знать сколько 
требуется усилий чтобы определить какой из двух файлов был создан 
первым, например. А все из-за того, что в Си нет встроенных средств для 
такого рода сравнения. Вместо этого приходится использовать системный 
вызов stat() для каждого файла и затем сравнивать результат вручную. Но в
 bash есть встроенный механизм сравнения файлов, Поэтому узнать 
"доступен ли для чтения файл /tmp/myfile" настолько же просто как и 
узнать "превосходит ли значение переменной 'myvar' 4".</p>
<p>Привожу список наиболее часто употребляемых в bash операторов сравнения</p>
<strong>Файлы</strong>

<dl>
<dt>-a file</dt><dd>истинно если файл существует.</dd>
<dt>-d file</dt><dd>истинно если файл существует и является директорией.</dd>
<dt>-f file</dt><dd>истинно если файл существует и является обычным файлом.</dd>
<dt>-r file</dt><dd>истинно если файл существует и доступен для чтения.</dd>
<dt>-s file</dt><dd>истинно если файл существует и его размер больше 0.</dd>
<dt>-w file</dt><dd>истинно если файл существует и доступен для записи.</dd>
<dt>-x file</dt><dd>истинно если файл существует и является исполняемым.</dd>
</dl>

<dl>
<dt>file1 -nt file2</dt><dd>истинно если файл file1 новее чем file2 или file1 (в соответствии со временем последнего изменения) существует, а file2 нет.</dd>
<dt>file1 -ot file2</dt><dd>истинно если файл file1 старше чем file2 или file2 существует, а file1 нет.</dd>
<dt>file1 -ef file2</dt><dd>истинно если оба файла ссылаются на одно и то же устройство или инод.</dd>
</dl>

<strong>Строки</strong>
<dl>
<dt>-z string</dt><dd>истинно если строка имеет нулевую длину.</dd>
<dt>-n string</dt><dd>истинно если длина строки не нулевая.</dd>
<dt>string1 = string2</dt><dd>истинно если строки равны.</dd>
<dt>string1 != string2</dt><dd>истинно если не равны.</dd>
<dt>string1 &lt; string2</dt><dd>истинно если строка 1 стоит в алфавитном порядке перед строкой 2.</dd>
<dt>string1 &gt; string2</dt><dd>истинно если строка 1 стоит в алфавитном порядке после строки 2.</dd>
</dl>

<p>В следующих примерах показано как использовать оператор сравнения в конструкции "if":</p>
<code>if [ -z "$myvar" ]
then
     echo "Переменная 'myvar' не определена."
fi</code>
<p>Квадратные скобки вычисляют условное выражение стоящее в них (это синоним встроенной функции bash — <b>test</b>).
 Возвращаемый результат — 1 или 0 в зависимости от того выполняется 
условие или нет. в скобках может стоять несколько выражений, связанных 
логическими операторами "<b>и</b>" или "<b>или</b>". Подробнее на странице справки <b>help test</b>.</p>
<p>В некоторых случаях одна и та же операция сравнения может быть 
сделана несколькими разными способами. Обе конструкции из следующего 
примера функционально идентичны:</p>
<code>if [ "$myvar" -eq 3 ]
then 
     echo "myvar равно 3"
fi

if [ "$myvar" = "3" ]
then
     echo "myvar равно 3"
fi</code>
<p>В первой конструкции из предыдущего примера использована операция 
арифметического сравнения, а во втором — операция сравнения строк.</p>

<h3>Тонкости при сравнении строк</h3>
<p>В большинстве случаев, когда вы не заключаете строки и строковые 
переменные в двойные кавычки, это может привести к ошибке. Почему? Да 
потому что в строке может встретится пробел или символ табуляции, 
которые bash не сможет правильно обработать. Вот пример некорректного 
сравнения строк:</p>
<code>if [ $myvar = "foo bar oni" ]
then
     echo "yes"
fi</code>
<p>В этом примере, если значение переменной "$myvar" будет равно "foo", 
код будет работать как и ожидается и не печатать ничего. Но если 
значение переменной "$myvar" будет равно "foo bar oni", скрипт вызовет 
следующую ошибку:</p>
<code>[: too many arguments</code>
<p>После подстановки значения переменной, bash пытается произвести следующую операцию сравнения:</p>
<code>[ foo bar oni = "foo bar oni" ]</code>
<p>В этом случае bash не может правильно обработать сравнение строк 
содержащих пробелы, одна из которых  не заключена в двойные кавычки. 
Интерпретатор думает, что в квадратных скобках слишком много аргументов.
 После заключения переменной в двойные кавычки, ошибка не возникает и 
код работает так как мы задумали. Запомните, если вы возьмете в привычку
 заключать в двойные кавычки все строковые аргументы и переменные, то 
избежите множества ошибок подобных описанной выше. Вот исправленный 
кусок кода:</p>
<code>if [ "$myvar" = "foo bar oni" ]
then
    echo "yes"
fi</code>
<p>Этот код будет работать корректно и не преподнесет нам больше никаких неприятных сюрпризов.</p>
<div class="note"><strong>Замечание</strong>: Если вы хотите, чтобы 
подстановка значений переменных продолжала работать, заключайте их в 
двойные кавычки а не в одинарные. Одинарные кавычки отключают 
подстановку значения переменных.</div>

<h3>Конструкция создания циклов "for"</h3>
<p>Хорошо, с условными переходами разобрались, пора перейти к циклическим конструкциям. Начнем с управляющей конструкции "<b>for</b>". Вот стандартный пример:</p>
<code>#!/bin/bash

for x in one two three four
do
    echo "number $x"
done

<b>Результат</b>:
number one
number two 
number three 
number four</code>
<p>Что же именно произошло? Часть "for x" цикла "for" определяет 
переменную (называемую итератором) "$x", которая последовательно 
принимает значения "one", "two", "three", и "four" (по одному за один 
такт цикла). После присвоения каждого нового значения переменной "$x", 
выполняется тело цикла (код между словами "do" и "done"). В теле цикла 
мы выводим на печать значение переменной "$x". Заметим, что после слова 
"in" в конструкции "for" всегда стоит некий список. В данном примере мы 
указали четыре слова, но этот список может содержать имена файлов или 
даже шаблон (wildcard). В следующем примере показано как использовать 
шаблоны при инициализации итератора цикла:</p>
<code>#!/bin/bash

for myfile in /etc/r*
do
    if [ -d "$myfile" ] 
    then
      echo "$myfile (dir)"
    else
      echo "$myfile"
    fi
done

результат:
/etc/rc0.d (dir)
/etc/rc1.d (dir)
/etc/rc2.d (dir)
/etc/rc3.d (dir)
/etc/rc4.d (dir)
/etc/rc5.d (dir)
/etc/rc6.d (dir)
/etc/rc.local
/etc/rcS.d (dir)
/etc/rearj.cfg
/etc/reportbug.conf
/etc/resolvconf (dir)
/etc/resolv.conf
/etc/rmt
/etc/rpc
/etc/rsyslog.conf
/etc/rsyslog.d (dir)</code>
<p>Код этого цикла исполнится для каждого файла из /etc/ имя которого 
начинается с "r". Сначала bash найдет все такие файлы и заменит шаблон 
строкой <b>/etc/rc0.d /etc/rc1.d /etc/rc2.d /etc/rc3.d /etc/rc4.d ... /etc/rsyslog.d</b>
 перед тем как приступить к выполнению цикла. В теле цикла для каждого 
файла из списка проверяется является ли этот файл директорией при помощи
 оператора "<b>-d</b>". Если файл оказался директорией, рядом с его называнием печатается "(dir)".</p>
<p>В списке инициализации итератора можно использовать несколько шаблонов одновременно и даже переменные окружения:</p>
<code>for x in /etc/r??? /var/lo* /home/drobbins/mystuff/* /tmp/${MYPATH}/*
do
    cp $x /mnt/mydira
done</code>
<p>Bash в этом примере подставляет значение переменной и раскрывает шаблоны. А затем копирует все файлы в заданную директорию.</p>
<p>До этого все примеры содержали шаблоны основанные на абсолютных путях, но можно использовать и относительные:</p>
<code>for x in ../* mystuff/*
do
     echo "$x is a silly file"
done</code>
<p>В этом примере bash раскрывает шаблон относительно текущей рабочей 
директории (не той в которой находится скрипт, а той которую показывает 
команда "pwd"). Поиграйтесь с этим скриптом, позапускайте его из разных 
директорий и посмотрите на результат.</p>
<p>Иногда может потребоваться запустить цикл по списку аргументов из командной строки. Вот как это делается:</p>
<code>#!/bin/bash

for i in "$@"
do
    echo "Вы написали: ${i}."
done

результат:
$ <b>./test.sh hello there you silly</b>
Вы написали: hello.
Вы написали: there.
Вы написали: you.
Вы написали: silly.</code>
<p>В этом примере мы использовали переменную "<b>$@</b>" о которой говорили выше.</p>

<h3>Арифметика в shell</h3>
<p>Перед тем как приступить к разбору следующего вида циклической 
конструкции, научимся при помощи интерпретатора производить простые 
арифметические операции. Просто заключите арифметическое выражение в 
конструкцию "<b>$((&nbsp;))</b>" и bash посчитает ее значение. Вот несколько примеров:</p>
<code>$ <b>echo $(( 100 / 3 ))</b>
33
$ <b>myvar="56"</b>
$ <b>echo $(( $myvar + 12 ))</b>
68
$ <b>echo $(( $myvar - $myvar ))</b>
0
$ <b>myvar=$(( $myvar + 1 ))</b>
$ <b>echo $myvar</b>
57</code>
<p>Теперь, когда вы познакомились с вычислением арифметических выражений
 в shell, пришло время рассказать о циклических конструкциях "while" и 
"until".</p>

<h3>Циклические конструкции с условиями ("while" и "until")</h3>
<p>"while"–цикл исполняется пока выражение в квадратных скобках истинно. Он имеет следующий формат:</p>
<code>while [ условие ]
do
    код
done</code>
<p>В следующем примере тело цикла исполняется ровно 10 раз:</p>
<code>myvar=0
while [ $myvar -ne 10 ]
do
    echo "$myvar"
    myvar=$(( $myvar + 1 ))
done</code>
<p>После каждого выполнения кода тела цикла переменная "myvar" 
увеличивается на 1. Когда значение переменной становится равным 10, 
условие в квадратных скобках не выполняется и цикл прерывается.</p>

<p>"Until"–цикл очень похож на "while"–цикл: он повторяется пока 
выражение в квадратных скобках ложно. Вот пример "until"–цикла по 
функциональности идентичного "while"–циклу из предыдущего примера:</p>
<code>myvar=0
until [ $myvar -eq 10 ]
do
    echo $myvar
    myvar=$(( $myvar + 1 ))
done</code>

<h3>Экстренный выход из цикла</h3>
<p>Для экстренного выхода из "for", "while" или "until" цикла используется команда <b>break</b>. Для выхода из нескольких вложенных циклов — <b>break N</b>, где N — количество вложенных циклов.</p>
<code>name=0
while :
do
   wget http://example.com/gallery/${name}.png
   [ $? -ne 0 ] &amp;&amp; break
done</code>
<p>В последнем примере: "<b>while :</b>" — бесконечный цикл. Двоеточие — это команда bash которая не делает ничего но всегда завершается успехом. Переменная <b>$?</b> содержит статус с которым завершилась последняя команда (подробнее о специальных переменных смотри <b>man bash</b>).
 В нашем случае код отличный от 0 обозначает что при скачивании файла 
произошла ошибка. Как только условие в квадратных скобках выполнено, 
интерпретатор переходит к исполнению команды стоящей после логического и
 (&amp;&amp;). Break прерывает выполнение цикла.</p>
<p>Предпоследнюю строку предыдущего примера можно заменить на знакомую 
нам условную конструкцию "if" (помним, что в bash одно действие можно 
сделать несколькими разными способами):</p>
<code>[ $? -ne 0 ] &amp;&amp; break</code>
<p>то же самое но через условную конструкцию:</p>
<code>if [ $? -ne 0 ]
then
      break
fi</code>
<p>Или в одну строку</p>
<code>if [ $? -ne 0 ]; then break; fi</code>
<p>Да, конструкции можно записывать в одну строку, только нужно 
поставить несколько разделяющих знаков "точка с запятой". Но не стоит 
привыкать к такой форме записи — это усложняет читаемость кода.</p>

<h3>Команда–переключатель "case"</h3>
<p>Конструкция условного перехода "case" может оказаться очень полезной. Вот пример ее использования:</p>
<code>case "${x##*.}" in
     gz)            gzunpack ${SROOT}/${x} ;;
     bz2)           bz2unpack ${SROOT}/${x} ;;
     *)             echo "Формат архива не определен."
                    exit
                    ;;
esac</code>
<p>В этом примере сначала происходит обработка строки в переменной "$x" — "${x##*.}". Как мы помним из <a href="http://linuxgeeks.ru/bash-1.htm" title="Bash в примерах. Часть 1.">первой статьи</a>,
 после этой операции в переменной "$x" остается только расширение файла.
 Затем bash сравнивает это расширение с вариантами стоящими слева от 
одинарных скобок "<b>)</b>". Если совпадение найдено, выполняется 
соответствующее действие. Если совпадения не найдено, никаких действий 
не выполняется, но в данном конкретном коде совпадение будет всегда, 
потому что в последней строке стоит шаблон "<b>*</b>", совпадающий с любой последовательностью символов.</p>

<h3>Функции и пространство имен</h3>
<p>В bash вы можете определять свои функции, как и в других языках 
программирования (C, Pascal...). Эти функции могут принимать аргументы, 
используя механизм очень похожий на механизм работы с аргументами 
командной строки. Вот пример определения простой функции:</p>
<code>tarview() {
    echo -n "Displaying contents of $1 "
    if [ ${1##*.} = tar ]
    then
        echo "(uncompressed tar)"
        tar tvf $1
    elif [ ${1##*.} = gz ]
    then
        echo "(gzip-compressed tar)"
        tar tzvf $1
    elif [ ${1##*.} = bz2 ]
    then
        echo "(bzip2-compressed tar)"
        cat $1 | bzip2 -d | tar tvf -
    fi
}</code>
<div class="note">Эта функция может быть переписана с использованием конструкции "<b>case</b>". Сможете ли вы проделать это самостоятельно?</div>
<p>Выше мы определили функцию с именем "tarview", которая принимает один
 аргумент — имя тарбола. Эта функция определяет вид тарбола (без сжатия,
 сжатый gzip-ом или bzip2) по расширению, затем печатает этот тип и 
показывает содержимое архива. Если формат определить не удалось, 
выводится соответствующее сообщение. Вот пример вызова функции:</p>
<code>$ <b>./tarview.sh shorten.tar.gz</b>
Displaying contents of shorten.tar.gz (gzip-compressed tar)
drwxr-xr-x ajr/abbot         0 1999-02-27 16:17 shorten-2.3a/
-rw-r--r-- ajr/abbot      1143 1997-09-04 04:06 shorten-2.3a/Makefile
-rw-r--r-- ajr/abbot      1199 1996-02-04 12:24 shorten-2.3a/INSTALL
-rw-r--r-- ajr/abbot       839 1996-05-29 00:19 shorten-2.3a/LICENSE
....</code>
<p>Как вы видите, обращение к аргументам внутри функции происходит по 
тем же именам как и к аргументам командной строки внутри скрипта. 
Переменная "<b>$#</b>" содержит количество переданных функции аргументов. Единственное что остается по-прежнему — переменная "<b>$0</b>".
 Она содержит название скрипта при вызове функции из скрипта или строку 
"bash" при вызове функции напрямую из командной строки.</p>
<p>Вызвать функцию из командной строки можно следующим образом: 
сохраняем код функции в файл (например с названием "myfunc.txt") а затем
 даем следующую команду:</p>
<code>$ <b>. myfunc.txt</b></code>
<p>или что тоже самое</p>
<code>$ <b>source myfunc.txt</b></code>
<p>Эти команды строка за строкой исполняют инструкции написанные в файле
 в текущей командной оболочке. (Можно так же напечатать код функции 
строка за строкой в командной строке, но первый способ намного удобнее).
 После этого можем вызывать нашу функцию прямо из командной строки:</p>
<code>$ <b>tarview shorten.tar.gz</b></code>
<div class="note"><strong>Замечание</strong>: любая функция может быть записана в файл <i>~/.bashrc</i> или <i>~/.bash_profile</i>, тогда вы сможете вызывать ее из командной строки в любое время при следующем логине.</div>

<h3>Пространство имен</h3>
<p>Часто возникает потребность создать переменную окружения внутри 
функции. В большинстве компилируемых языков (например Си), когда вы 
создаете переменную внутри функции, она попадает в отдельное 
пространство имен этой функции. Например, если вы напишите функцию "my 
function" на C и внутри этой функции создадите переменную "x", то она 
никак не повлияет на переменную с тем же именем "x", созданную вне 
функции "myfunction".</p>
<p>Но в bash все по-другому. В bash, когда вы создаете переменную внутри
 функции, она попадает в общее пространство имен. Это значит, что она 
может перезаписать значение глобальной переменной с таким же именем и 
продолжит свое существование даже после завершения исполнения функции:</p>
<code>#!/bin/bash

myvar="hello"

myfunc() {

    myvar="one two three"
    for x in $myvar
    do
        echo $x
    done
}

myfunc

echo $myvar $x</code>
<p>Результатом исполнения этого кода будет строка "<i>ne two three three</i>",
 показывающая что переменная "myvar", созданная внутри функции 
перезаписала значение глобальной переменной "myvar" и что последнее 
значение итератора "x" равное "three" продолжило существование даже 
после завершения функции.</p>
<p>В этом простом примере ошибку легко заметить и устранить, 
переименовав переменные внутри функции. Но есть гораздо более правильное
 решение этой проблемы: при создании переменной можно явно указать что 
она является локальной при помощи инструкции "<b>local</b>". Созданная 
таким способом внутри функции переменная будет отнесена к локальному 
пространству имен этой функции и не сможет никак повлиять на глобальную 
переменную с таким же именем. Следующий пример демонстрирует возможность
 создания локальной переменной:</p>
<code>#!/bin/bash

myvar="hello"

myfunc() {
    local x
    local myvar="one two three"
    for x in $myvar
    do
        echo $x
    done
}

myfunc

echo $myvar $x</code>
<p>Результатом выполнения этого кода будет строка "<i>hello</i>" — 
значение глобальной переменной "myvar" (на которую никак не повлияла 
локальная переменная "myvar", созданная внутри функции), а локальная 
переменная "x" перестает существовать после завершения функции.</p>
<p>Единственное условие при котором вы не должны использовать локальные 
переменные внутри функций — если хотите изменить значение глобальной 
переменной.</p>

<h3>Подведение итогов</h3>
<p>Вот и все. Теперь вы имеете представление о программировании в bash и
 можете писать свои скрипты. За более подробной информацией обращайтесь к
 справке <b>man bash</b> или к руководству <a href="http://tldp.org/LDP/abs/html/" title="An in-depth exploration of the art of shell scripting" target="_blank">Advanced Bash-Scripting Guide</a></p>

<h4>Смотри также</h4>
<ul>
<li><a href="http://linuxgeeks.ru/bash-intro.htm" title="Основы Linux: введение в bash.">Основы Linux: введение в bash</a></li>
<li><a href="http://linuxgeeks.ru/bash-1.htm" title="Bash в примерах. Часть 1.">Bash в примерах. Часть 1.</a></li>
</ul>
<hr>
<p>Оригинал статьи— <a href="http://www.funtoo.org/wiki/Bash_by_Example,_Part_2" title="Bash by example, Part 2" target="_blank">Bash by example, Part 2</a> (eng)</p>

</div>

<div class="sidenav">
<h2>Популярные статьи</h2>

<ul><li><a href="http://linuxgeeks.ru/debian-archiv.htm" title="Локальный репозитарий Debian linux">Локальный репозитарий Debian linux</a></li>
<li><a href="http://linuxgeeks.ru/firstime.htm" title="Какой linux выбрать?">Какой linux выбрать?</a></li>
<li><a href="http://linuxgeeks.ru/disk.htm" title="Разметка жёсткого диска при установке linux">Разметка жёсткого диска при установке linux</a></li>
<li><a href="http://linuxgeeks.ru/shell.htm" title="Основные команды администрирования linux">Основные команды администрирования linux</a></li>
<li><a href="http://linuxgeeks.ru/kernel.htm" title="Ручная сборка ядра linux">Ручная сборка ядра linux</a></li>
<li><a href="http://linuxgeeks.ru/vi.htm" title="Использование редактора Vim">Использование редактора Vim</a></li>
<li><a href="http://linuxgeeks.ru/sed.htm" title="Потоковый редактор SED">Потоковый редактор SED</a></li>
<li><a href="http://linuxgeeks.ru/awk.htm" title="Язык обработки шаблонов AWK">Язык обработки шаблонов AWK</a></li>
<li><a href="http://linuxgeeks.ru/smb.htm" title="Firefox + samba">Firefox + samba</a></li>
<li><a href="http://linuxgeeks.ru/live-usb.htm" title="Создание Live-usb">Создание Live-usb</a></li>
<li><a href="http://linuxgeeks.ru/web-browser.htm" title="Сравнение бесплатных веб-браузеров">Сравнение бесплатных веб-браузеров</a></li>
<li><a href="http://linuxgeeks.ru/ext3grep.htm" title="Восстановление файлов на ext3">Восстановление файлов на ext3</a></li>
<li><a href="http://linuxgeeks.ru/bash-intro.htm" title="Введение в bash">Введение в bash</a></li>
<li><a href="http://linuxgeeks.ru/bash-1.htm" title="Bash в примерах. Часть I.">Bash в примерах. Часть I.</a></li>
<li class="active"><a href="http://linuxgeeks.ru/bash-2.htm" title="Bash в примерах. Часть II.">Bash в примерах. Часть II.</a></li>
<li><a href="http://linuxgeeks.ru/djvu.htm" title="Создание документов DJVU">Создание документов DJVU</a></li>
<li><a href="http://linuxgeeks.ru/try-linux.htm" title="Как попробовать линукс">Как попробовать линукс</a></li>
<li class="last"><a href="http://linuxgeeks.ru/my-software-choice.htm" title="Вариант набора ПО для GNU/Linux">Вариант набора ПО для GNU/Linux</a></li>
</ul>


<div class="lg-sq">
<script async="" src="Bash%20%D0%B2%20%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D0%B0%D1%85.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%202._files/adsbygoogle.js"></script>
<!-- lg-sq -->
<ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-8433592019700240" data-ad-slot="4866229215" data-adsbygoogle-status="done"><ins id="aswift_0_expand" style="display:inline-table;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><ins id="aswift_0_anchor" style="display:block;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><iframe marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_0" name="aswift_0" style="left:0;position:absolute;top:0;width:336px;height:280px;" width="336" height="280" frameborder="0"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>

	</div>

<div class="clearer"></div>

</div>
<div class="pad"></div>
</div>

<!-- Copyrites -->
<div class="footer">
<div>
<!--noindex-->
<!--LiveInternet counter--><script type="text/javascript"><!--
document.write("<a href='//www.liveinternet.ru/click' "+
"target=_blank><img src='//counter.yadro.ru/hit?t45.11;r"+
escape(document.referrer)+((typeof(screen)=="undefined")?"":
";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
";h"+escape(document.title.substring(0,80))+";"+Math.random()+
"' alt='' title='LiveInternet' "+
"border='0' width='31' height='31'><\/a>")
//--></script><a href="http://www.liveinternet.ru/click" target="_blank"><img src="Bash%20%D0%B2%20%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D0%B0%D1%85.%20%D0%A7%D0%B0%D1%81%D1%82%D1%8C%202._files/hit.gif" alt="" title="LiveInternet" width="31" height="31" border="0"></a><!--/LiveInternet-->
<!--/noindex-->
</div>
<p>© 2009-2014 <a href="http://linuxgeeks.ru/">LinuxGeeks.ru</a> -- <a href="http://linuxgeeks.ru/sitemap.htm">Карта сайта</a></p>
</div>
<!-- Copyrites -->

</body></html>